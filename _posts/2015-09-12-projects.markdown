---
layout: post
title: "Design: Not For The Weak Of Mind"
date: 2015-09-12
categories:
---
We got Labor Day off this week, so we only had two classes. An alumni from UT who now works at Bloomberg came and gave a talk on Wednesday, so we really only had one class.

One thing that occurs in this class is that outside speakers are brought in to talk about life after UT. So on Wednesday we had an outside speaker who talked about his life at Bloomberg. He gave some tips about resumes and interviewing, so that was handy. Of course, the talk had a certain slant towards us applying to Bloomberg. It seems like a nice place, but I'm not sure NYC is cut out for me. They probably have tighter UAV laws - Austin has plenty of schools which will let you fly UAVs on them, so maybe this summer I'm going to stay in Austin again.

Friday, on the other hand, was essentially a survey class of things that are wrong with C++. One such issue with C++ is passing by reference. We really only touched on it tangentally when talking about exceptions, but here's my problem with pass-by-reference. Examine the following piece of code:

```
Integer a = 1;
Integer b = 2;
a.setMax(b);
```

Now, a simple question. What is a after this snippet of code runs?

You might initially think, well, it's 2. But that answer only comes from convention. Conventionally, a.setMax(b) changes a but not b.

But you don't know that. Integer is in this case some 3rd party library - it wasn't written by you, the reader, so you have to guess that the writer of Integer followed the same convention you follow.

The problem in this case is that setMax's prototype is:

```
void Integer::setMax(Integer &other);
```

And there is ambiguity here. C++ has pointers, there is no reason not to use them:

```
void Integer::setMax(Integer *other);
```

This disambiguates to the reader of the code both inside the function and outside where the variable "other" is stored - it is stored somewhere else, not on the local stack:

```
Integer a = 1;
Integer b = 2;
a.setMax(&b);
```

Now it's clear that, even if b is not changed, setMax() is allowed to change b. By adding the ampersand the programmer has given permission for setMax to change b. Otherwise, the programmer may not realize that b could be changed.

One could argue that this is a problem only with "poorly-written" libraries, which don't follow the conventions. The counter-argument is that yes, that's true, but you could just as well design the language to prevent such poorly-written libraries from existing.

As I mentioned, the class on Friday revolved more around exceptions than passing by reference. I have nothing against exceptions.

In other news, we finished the project this week. I have little to say about the project that I haven't said already: it tries to teach us tools by forcing us to use them without any rationale (see my prior rant on issue tracking).

For instance, I believe that source control should be used to control source.

Doxygen is a tool that generates documentation. The documentation comes from comments in the source code of files, and Doxygen can be controlled using a Doxyfile much like how make is controlled with a Makefile. Doxygen generates HTML documentation and plops it into a html/ directory.

Proper use of source control, I think most people would agree, would be to commit the source code and the Doxyfile, and not the html/ directory. The html/ directory is generated, and committing it would be like committing a compiled binary.

But alas, the project requirements require us to commit the html directory and not the Doxyfile, even though we hand-modified the Doxyfile.

What's the lesson we're being taught? I don't know. The rationale for these unusual requirements is that employers will need to know that prospective employees (i.e. us students) can pay attention to detail.

I've worked at a half-dozen different companies. Every single one valued employees speaking up about things like this more than a blind ambition to stick to requirements.

Which brings me to...

Tip of the Week: Don't blindly use git add -A before every commit. You will eventually grab all manner of binary files, temporary log files, test files, editor scratch files, and so forth. When you do grab those files, you inconvenience everyone else.

Story time: In Spring of 2015 I had Dr. Rellermeyer for Operating Systems. There was a big final project for the second half of the semester, which was to build an operating system that would run on an ARM chip (Raspberry Pi, in particular).

That project was in my opinion how projects should be done. We were essentially a pretend company - Dr. Rellermeyer was a customer, who said "I need an OS that can run a binary". The rest of us self-organized to accomplish that goal, like any real-world company.

There were two dozen of us, all frantically compiling the code and trying to get it to work. One day somebody accidentally pushed the binary executable and 20MB of log file. For the next week, everybody got a nasty case of merge hell, because the binary changes on every commit. On top of that, they would overwrite their own binary whenever they pulled from the repo, and then spend forever trying to figure out why their code didn't seem to be running.

Moral of the story: Add only files you know about.
